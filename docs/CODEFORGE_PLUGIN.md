# CodeForge Plugin - Proactive Code Intelligence

## Core Philosophy

**ĞĞ•**: Ğ½Ğ°Ğ¿Ğ¸ÑĞ°Ğ» ĞºĞ¾Ğ´ â†’ Ğ¿Ñ€Ğ¾Ñ‚ĞµÑÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ» â†’ Ğ½Ğ°ÑˆÑ‘Ğ» ÑƒĞ·ĞºĞ¸Ğµ Ğ¼ĞµÑÑ‚Ğ° â†’ Ğ¾Ğ¿Ñ‚Ğ¸Ğ¼Ğ¸Ğ·Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ»

**Ğ”Ğ**: Ğ¿Ğ»Ğ°Ğ½Ğ¸Ñ€ÑƒÑ Ğ·Ğ°Ğ´Ğ°Ñ‡Ñƒ â†’ Ğ¸Ñ‰Ñƒ Ğ»ÑƒÑ‡ÑˆĞ¸Ğ¹ Ğ¿Ğ°Ñ‚Ñ‚ĞµÑ€Ğ½ â†’ **ÑÑ€Ğ°Ğ·Ñƒ Ğ¿Ğ¸ÑˆÑƒ Ğ¾Ğ¿Ñ‚Ğ¸Ğ¼Ğ°Ğ»ÑŒĞ½Ñ‹Ğ¹ ĞºĞ¾Ğ´**

CodeForge **Ğ¿ĞµÑ€ĞµÑ…Ğ²Ğ°Ñ‚Ñ‹Ğ²Ğ°ĞµÑ‚ Ğ¿Ñ€Ğ¾Ñ†ĞµÑÑ Ğ½Ğ° ÑÑ‚Ğ°Ğ¿Ğµ Ğ¿Ğ»Ğ°Ğ½Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ** Ğ¸ Ğ¸Ğ½Ğ¶ĞµĞºÑ‚Ğ¸Ñ‚ Ğ»ÑƒÑ‡ÑˆĞ¸Ğµ Ñ€ĞµÑˆĞµĞ½Ğ¸Ñ Ğ”Ğ Ñ‚Ğ¾Ğ³Ğ¾, ĞºĞ°Ğº Claude Ğ½Ğ°Ñ‡Ğ½Ñ‘Ñ‚ Ğ¿Ğ¸ÑĞ°Ñ‚ÑŒ ĞºĞ¾Ğ´.

## How It Works

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    TRADITIONAL APPROACH                          â”‚
â”‚                                                                  â”‚
â”‚  User Request â†’ Claude Plans â†’ Writes Naive Code â†’ Tests â†’      â”‚
â”‚  Finds Bottlenecks â†’ Optimizes â†’ Tests Again â†’ Done             â”‚
â”‚                                                                  â”‚
â”‚  Problem: Wasted cycles, reactive optimization                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    CODEFORGE APPROACH                            â”‚
â”‚                                                                  â”‚
â”‚  User Request â†’ CodeForge Intercepts â†’ Analyzes Intent â†’        â”‚
â”‚  Searches Knowledge Base â†’ Finds Best Patterns â†’                â”‚
â”‚  Injects Into Claude's Context â†’ Claude Writes Optimal Code     â”‚
â”‚                                                                  â”‚
â”‚  Result: Best code from the start, no wasted iterations         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Architecture

### Interception Layer

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     USER PROMPT                                   â”‚
â”‚  "Write a function to find duplicates in large array"            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                               â”‚
                               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   CODEFORGE INTERCEPTOR                          â”‚
â”‚                                                                  â”‚
â”‚  1. INTENT ANALYSIS                                              â”‚
â”‚     â””â”€ Detects: "duplicate finding", "large array", "performance"â”‚
â”‚                                                                  â”‚
â”‚  2. KNOWLEDGE BASE SEARCH                                        â”‚
â”‚     â””â”€ Query: find_duplicates + large_data + python              â”‚
â”‚     â””â”€ Found: 5 patterns, best = Counter-based (234x faster)     â”‚
â”‚                                                                  â”‚
â”‚  3. CONTEXT INJECTION                                            â”‚
â”‚     â””â”€ Adds to Claude's prompt:                                  â”‚
â”‚        "Use Counter-based approach for O(n) complexity.          â”‚
â”‚         Avoid nested loops. Reference implementation: ..."       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                               â”‚
                               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     CLAUDE CODE                                   â”‚
â”‚                                                                  â”‚
â”‚  Now writes optimal code FROM THE START because it has:          â”‚
â”‚  - Best known pattern                                            â”‚
â”‚  - Performance characteristics                                   â”‚
â”‚  - Reference implementation                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Planning Phase Integration

When Claude Code creates a plan, CodeForge analyzes EACH step:

```
Original Plan:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 1. Create data models                  â”‚
â”‚ 2. Implement search function           â”‚  â† CodeForge: "Use binary search 
â”‚ 3. Build API endpoint                  â”‚     with bisect, 50x faster"
â”‚ 4. Add caching                         â”‚  â† CodeForge: "Use LRU with 
â”‚ 5. Write tests                         â”‚     functools, not manual dict"
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Enhanced Plan (with CodeForge):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 1. Create data models                                          â”‚
â”‚ 2. Implement search function                                   â”‚
â”‚    â””â”€ [CODEFORGE] Use bisect.bisect_left for O(log n)         â”‚
â”‚    â””â”€ [CODEFORGE] Pattern: optimized_binary_search_v3         â”‚
â”‚ 3. Build API endpoint                                          â”‚
â”‚ 4. Add caching                                                 â”‚
â”‚    â””â”€ [CODEFORGE] Use @lru_cache(maxsize=1024)                â”‚
â”‚    â””â”€ [CODEFORGE] Pattern: smart_caching_decorator            â”‚
â”‚ 5. Write tests                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Knowledge Base

### Pattern Storage

```yaml
pattern:
  id: "fast_duplicate_finder_v3"
  name: "Counter-based Duplicate Finder"
  
  # What problem does this solve?
  intent:
    keywords: ["duplicate", "find", "array", "list", "repeated"]
    description: "Finding duplicate elements in a collection"
    
  # When to use this pattern
  conditions:
    - data_size: ">1000 elements"
    - data_type: "hashable items"
    - requirement: "find all duplicates"
    
  # The optimal implementation
  implementation:
    language: python
    code: |
      def find_duplicates(arr):
          from collections import Counter
          counts = Counter(arr)
          return [item for item, count in counts.items() if count > 1]
    
  # Performance characteristics
  performance:
    time_complexity: "O(n)"
    space_complexity: "O(n)"
    speedup_vs_naive: 234
    benchmark_data:
      - input_size: 10000
        naive_ms: 2340
        optimized_ms: 10
        
  # What NOT to do
  anti_patterns:
    - name: "nested_loop"
      why_bad: "O(nÂ²) complexity, unusable for large data"
      code_smell: "for i in range... for j in range..."
```

### Intent Matching

CodeForge understands WHAT you want to do, not just keywords:

```python
# These all match "duplicate finding" pattern:

"find duplicates in array"           â†’ fast_duplicate_finder
"get repeated elements"              â†’ fast_duplicate_finder  
"which items appear more than once"  â†’ fast_duplicate_finder
"remove unique, keep only dupes"     â†’ fast_duplicate_finder
"Ğ½Ğ°Ğ¹Ñ‚Ğ¸ Ğ¿Ğ¾Ğ²Ñ‚Ğ¾Ñ€ÑÑÑ‰Ğ¸ĞµÑÑ ÑĞ»ĞµĞ¼ĞµĞ½Ñ‚Ñ‹"       â†’ fast_duplicate_finder
```

## Prompt Injection

### How CodeForge Modifies Claude's Context

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ORIGINAL USER PROMPT:                                           â”‚
â”‚ "Create a function to process large CSV and find duplicates"    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

                    â†“ CodeForge Intercepts â†“

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ENHANCED PROMPT (sent to Claude):                               â”‚
â”‚                                                                 â”‚
â”‚ [CODEFORGE CONTEXT - USE THESE PATTERNS]                        â”‚
â”‚                                                                 â”‚
â”‚ For CSV processing with large files:                            â”‚
â”‚ â€¢ Use pandas.read_csv(chunksize=10000) for memory efficiency   â”‚
â”‚ â€¢ Pattern: chunked_csv_processor (12x faster, 90% less memory) â”‚
â”‚                                                                 â”‚
â”‚ For finding duplicates:                                         â”‚
â”‚ â€¢ Use Counter-based approach, NOT nested loops                  â”‚
â”‚ â€¢ Pattern: fast_duplicate_finder (234x faster)                 â”‚
â”‚ â€¢ Reference: from collections import Counter                    â”‚
â”‚                                                                 â”‚
â”‚ Anti-patterns to AVOID:                                         â”‚
â”‚ â€¢ âŒ df.iterrows() - extremely slow                             â”‚
â”‚ â€¢ âŒ Nested loops for comparison                                â”‚
â”‚ â€¢ âŒ Loading entire file into memory                            â”‚
â”‚                                                                 â”‚
â”‚ [END CODEFORGE CONTEXT]                                         â”‚
â”‚                                                                 â”‚
â”‚ USER REQUEST:                                                   â”‚
â”‚ "Create a function to process large CSV and find duplicates"    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## MCP Tools

### `codeforge_plan_analyze`

Called automatically when Claude plans a task:

```json
{
  "plan_steps": [
    "Create user model",
    "Implement search",
    "Add pagination"
  ],
  "language": "python",
  "project_context": "FastAPI web service"
}
```

**Returns** enhanced plan with best patterns for each step.

### `codeforge_intent_search`

Searches knowledge base by intent:

```json
{
  "intent": "sort large dataset efficiently",
  "language": "python",
  "constraints": {
    "memory_limited": true,
    "data_size": "1GB+"
  }
}
```

**Returns** best matching patterns with implementations.

### `codeforge_get_pattern`

Gets specific pattern for immediate use:

```json
{
  "pattern_id": "fast_duplicate_finder_v3"
}
```

**Returns** full implementation ready to use.

### `codeforge_learn`

Stores new optimal pattern discovered during development:

```json
{
  "name": "parallel_json_parser",
  "intent": "parse large JSON files quickly",
  "implementation": "...",
  "benchmark_results": {...}
}
```

## Operating Modes

### Mode: `always` (Default)

Every Claude Code interaction goes through CodeForge:

```
1. User types request
2. CodeForge analyzes intent
3. CodeForge searches patterns
4. CodeForge injects context
5. Claude writes optimal code
```

**Overhead**: ~500ms for pattern search, minimal token increase

### Mode: `planning-only`

Only intercepts during planning phase:

```
1. User requests feature
2. Claude creates plan
3. CodeForge enhances plan with patterns
4. Claude executes with guidance
```

### Mode: `on-demand`

Manual activation:

```bash
/codeforge search "fast sorting for linked list"
/codeforge use pattern:timsort_linked
```

## Project RAG Integration

CodeForge indexes your entire project to:

1. **Understand existing patterns** - "You already use Counter in utils.py"
2. **Avoid duplication** - "Similar function exists at lib/helpers.py:45"
3. **Maintain consistency** - "Your project uses snake_case, not camelCase"
4. **Learn project-specific optimizations** - "Your custom cache is 3x faster for this use case"

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    PROJECT INDEX                                 â”‚
â”‚                                                                 â”‚
â”‚  Patterns Found in Your Code:                                   â”‚
â”‚  â”œâ”€ utils/cache.py â†’ custom_lru_cache (your implementation)    â”‚
â”‚  â”œâ”€ lib/search.py â†’ binary_search_with_fallback                â”‚
â”‚  â””â”€ core/data.py â†’ chunked_processor                           â”‚
â”‚                                                                 â”‚
â”‚  When writing new code:                                         â”‚
â”‚  â€¢ Reuse YOUR proven patterns first                            â”‚
â”‚  â€¢ Fall back to global knowledge base                          â”‚
â”‚  â€¢ Suggest improvements to existing patterns                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Continuous Development Mode

For autonomous app development, CodeForge guides the entire process:

```
User: "Build a delivery service API"

CodeForge + Claude Code:

â”Œâ”€ PHASE 1: PLANNING â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                 â”‚
â”‚ Plan created with 15 tasks                                     â”‚
â”‚ CodeForge found optimal patterns for 12/15 tasks               â”‚
â”‚                                                                 â”‚
â”‚ Task 3: "Implement geospatial search"                          â”‚
â”‚ â””â”€ [CODEFORGE] Use R-tree index, not brute force               â”‚
â”‚ â””â”€ Pattern: rtree_geo_search (500x faster for 10K+ points)     â”‚
â”‚                                                                 â”‚
â”‚ Task 7: "Order status updates"                                 â”‚
â”‚ â””â”€ [CODEFORGE] Use event sourcing pattern                      â”‚
â”‚ â””â”€ Pattern: event_sourcing_orders (better audit, undo support) â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€ PHASE 2: IMPLEMENTATION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                 â”‚
â”‚ Writing: services/geo.py                                       â”‚
â”‚ [CODEFORGE ACTIVE] Using pattern: rtree_geo_search             â”‚
â”‚                                                                 â”‚
â”‚ â†’ Optimal code written from start                              â”‚
â”‚ â†’ No refactoring needed                                        â”‚
â”‚ â†’ Tests included from pattern                                  â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Configuration

### `.codeforge.yml`

```yaml
codeforge:
  mode: always  # always | planning-only | on-demand
  
  # What to inject into prompts
  injection:
    patterns: true           # Include optimal patterns
    anti_patterns: true      # Warn about bad approaches
    project_context: true    # Reference existing code
    benchmarks: true         # Show performance data
    
  # Knowledge sources (priority order)
  knowledge:
    - source: project        # Your codebase first
      weight: 1.0
    - source: local_db       # Local pattern database
      weight: 0.8
    - source: codeforge_cloud  # Community patterns
      weight: 0.6
      
  # Intent matching sensitivity
  matching:
    threshold: 0.7           # Min similarity to suggest pattern
    max_suggestions: 3       # Patterns per intent
    
  # Learning
  learning:
    auto_learn: true         # Learn from your code
    min_speedup: 2.0         # Only learn if 2x+ faster
    require_tests: true      # Pattern must have tests
```

## Example Session

```
User: "Add a search feature to find products by name"

[CODEFORGE] Analyzing intent...
[CODEFORGE] Found 3 relevant patterns:
  1. fuzzy_search_trigram (handles typos, 95% accuracy)
  2. prefix_search_trie (instant autocomplete)  
  3. fulltext_search_postgres (best for large catalogs)

[CODEFORGE] Your project uses PostgreSQL â†’ recommending #3

[CODEFORGE] Injecting context into Claude...

Claude: "I'll implement product search using PostgreSQL full-text search
with GIN indexes, which is optimal for your setup.

Based on CodeForge patterns, I'll:
1. Add GIN index on product names
2. Use ts_vector for efficient matching
3. Include trigram similarity for fuzzy matching

Here's the implementation..."

[Writes optimal code directly, no iteration needed]
```

## Key Differentiators

| Traditional | CodeForge |
|-------------|-----------|
| Write â†’ Test â†’ Find slow â†’ Optimize | **Analyze â†’ Find best â†’ Write optimal** |
| Reactive optimization | **Proactive pattern injection** |
| Reinvent solutions | **Reuse proven patterns** |
| Learn after mistakes | **Know best practices upfront** |
| Manual research | **Automatic knowledge retrieval** |

---

## Scenario: No Pattern Found

When CodeForge doesn't have a known optimal solution:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ User: "Implement custom sorting for linked list with metadata"  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                  â”‚
                                  â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   CODEFORGE INTERCEPTOR                          â”‚
â”‚                                                                 â”‚
â”‚  Intent: "sorting" + "linked list" + "metadata"                 â”‚
â”‚  Knowledge Base Search: âŒ No exact match found                  â”‚
â”‚  Similar patterns: 3 (but different context)                    â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                  â”‚
                                  â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   CODEFORGE PROMPT                               â”‚
â”‚                                                                 â”‚
â”‚  âš ï¸  No optimal pattern found for this task.                    â”‚
â”‚                                                                 â”‚
â”‚  Options:                                                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ [1] Generate & Benchmark Variants                        â”‚   â”‚
â”‚  â”‚     Create 10-20 different implementations,              â”‚   â”‚
â”‚  â”‚     benchmark each, select the fastest                   â”‚   â”‚
â”‚  â”‚     â±ï¸ ~2-5 minutes                                       â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ [2] Use Best Practices (Skip Optimization)               â”‚   â”‚
â”‚  â”‚     Write standard implementation now,                   â”‚   â”‚
â”‚  â”‚     optimize later with Post-Dev Optimizer               â”‚   â”‚
â”‚  â”‚     â±ï¸ Immediate                                          â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ [3] Show Similar Patterns                                â”‚   â”‚
â”‚  â”‚     View 3 related patterns that might help              â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Option 1: Generate & Benchmark Variants

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                VARIANT GENERATION MODE                           â”‚
â”‚                                                                 â”‚
â”‚  Generating variants for: linked_list_metadata_sort             â”‚
â”‚                                                                 â”‚
â”‚  Strategy 1: Different algorithms                               â”‚
â”‚  â”œâ”€ Variant 1: Merge sort (recursive)                          â”‚
â”‚  â”œâ”€ Variant 2: Merge sort (iterative)                          â”‚
â”‚  â”œâ”€ Variant 3: Quick sort with random pivot                    â”‚
â”‚  â”œâ”€ Variant 4: Insertion sort (for small lists)                â”‚
â”‚  â””â”€ Variant 5: Tim sort hybrid                                 â”‚
â”‚                                                                 â”‚
â”‚  Strategy 2: Different data handling                            â”‚
â”‚  â”œâ”€ Variant 6: Convert to array, sort, rebuild                 â”‚
â”‚  â”œâ”€ Variant 7: In-place pointer manipulation                   â”‚
â”‚  â””â”€ Variant 8: Skip list intermediate structure                â”‚
â”‚                                                                 â”‚
â”‚  Strategy 3: Metadata-specific optimizations                    â”‚
â”‚  â”œâ”€ Variant 9: Cache comparison keys                           â”‚
â”‚  â””â”€ Variant 10: Schwartzian transform                          â”‚
â”‚                                                                 â”‚
â”‚  [â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘] 80% - Benchmarking...                  â”‚
â”‚                                                                 â”‚
â”‚  Results:                                                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ ğŸ¥‡ Variant 10: Schwartzian transform     â”‚ 12.3x faster â”‚   â”‚
â”‚  â”‚ ğŸ¥ˆ Variant 6: Array conversion           â”‚ 8.7x faster  â”‚   â”‚
â”‚  â”‚ ğŸ¥‰ Variant 2: Merge sort iterative       â”‚ 5.2x faster  â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                 â”‚
â”‚  [Use Winner] [Compare Top 3] [See All Results]                â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**After selection:**
- Winner is used in code
- Pattern saved to Knowledge Base for future use
- Next time similar task â†’ instant recommendation

---

## Post-Development Optimizer

Separate mode for analyzing already-written code.

### âš ï¸ IMPORTANT: Real Profiling, Not Style Checking

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                 â”‚
â”‚   âŒ WRONG APPROACH (what we DON'T do)                          â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                          â”‚
â”‚   "This function uses list comprehension instead of map()"      â”‚
â”‚   "Variable name doesn't follow PEP8"                           â”‚
â”‚   "You should use enumerate() here"                             â”‚
â”‚                                                                 â”‚
â”‚   This is LINTING, not optimization!                            â”‚
â”‚                                                                 â”‚
â”‚   âœ… RIGHT APPROACH (what we DO)                                â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                â”‚
â”‚   "This function takes 340ms (profiled) and is called 10K/hour" â”‚
â”‚   "Memory spikes to 2GB here (measured)"                        â”‚
â”‚   "This loop is 89% of total execution time (traced)"           â”‚
â”‚                                                                 â”‚
â”‚   Real data from real profilers!                                â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Profiling Tools Used

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    PROFILING STACK                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  TIME PROFILING                                                 â”‚
â”‚  â”œâ”€ cProfile        - Built-in, function-level timing           â”‚
â”‚  â”œâ”€ py-spy          - Sampling profiler, no code changes        â”‚
â”‚  â”œâ”€ scalene         - CPU + memory + GPU, line-level            â”‚
â”‚  â””â”€ pyinstrument    - Statistical profiler, call trees          â”‚
â”‚                                                                 â”‚
â”‚  MEMORY PROFILING                                               â”‚
â”‚  â”œâ”€ memory_profiler - Line-by-line memory usage                 â”‚
â”‚  â”œâ”€ tracemalloc     - Built-in, allocation tracking             â”‚
â”‚  â”œâ”€ objgraph        - Object reference graphs                   â”‚
â”‚  â””â”€ fil-profile     - High-memory line attribution              â”‚
â”‚                                                                 â”‚
â”‚  TRACING                                                        â”‚
â”‚  â”œâ”€ viztracer       - Flame graphs, timeline                    â”‚
â”‚  â”œâ”€ austin          - Frame stack sampler                       â”‚
â”‚  â””â”€ yappi           - Multi-threaded profiling                  â”‚
â”‚                                                                 â”‚
â”‚  BENCHMARKING                                                   â”‚
â”‚  â”œâ”€ pytest-benchmark - Comparative benchmarks                   â”‚
â”‚  â”œâ”€ pyperf          - Reliable micro-benchmarks                 â”‚
â”‚  â””â”€ asv             - Airspeed Velocity, historical tracking    â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### How Optimizer Finds Real Problems

```
/codeforge optimize --profile

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   PROFILING PROJECT                              â”‚
â”‚                                                                 â”‚
â”‚  Step 1: Running test suite with profiler attached...           â”‚
â”‚          [â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ] 100%                            â”‚
â”‚                                                                 â”‚
â”‚  Step 2: Analyzing profile data...                              â”‚
â”‚          Total execution time: 45.3s                            â”‚
â”‚          Memory peak: 1.2GB                                     â”‚
â”‚                                                                 â”‚
â”‚  Step 3: Identifying hotspots...                                â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              REAL PERFORMANCE DATA (from profiler)              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  ğŸ”¥ HOTSPOTS BY TIME                                            â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€    â”‚
â”‚  #  Function                      Time      %      Calls        â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€    â”‚
â”‚  1  services/geo.py:find_nearest  12.4s    27.4%   45,230      â”‚
â”‚  2  utils/json.py:parse_response   8.2s    18.1%  102,445      â”‚
â”‚  3  db/queries.py:get_orders       5.1s    11.3%   12,033      â”‚
â”‚  4  api/serialize.py:to_dict       3.8s     8.4%   89,221      â”‚
â”‚  5  core/calc.py:distance          2.9s     6.4%  450,120      â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€    â”‚
â”‚       Other (234 functions)       12.9s    28.4%                â”‚
â”‚                                                                 â”‚
â”‚  ğŸ§  HOTSPOTS BY MEMORY                                          â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€    â”‚
â”‚  #  Function                      Peak      Allocations         â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€    â”‚
â”‚  1  utils/json.py:parse_response  890MB    12.3M objects       â”‚
â”‚  2  services/report.py:generate   340MB     2.1M objects       â”‚
â”‚  3  db/queries.py:get_all         210MB     0.8M objects       â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€    â”‚
â”‚                                                                 â”‚
â”‚  Based on REAL profiler data, not style analysis!              â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Iterative Optimization (Multiple Runs)

### Run Modes

```bash
# Single run (default)
/codeforge optimize

# Specific number of iterations
/codeforge optimize --iterations=5

# Run until stopped (Ctrl+C)
/codeforge optimize --continuous

# Run until no improvement found
/codeforge optimize --until-plateau
```

### Unique Variants Across Iterations

**CRITICAL**: Each iteration generates DIFFERENT variants, never repeating previous ones.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                 ITERATION UNIQUENESS                             â”‚
â”‚                                                                 â”‚
â”‚  ITERATION 1 (--iterations=1)                                   â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                  â”‚
â”‚  Variants generated:                                            â”‚
â”‚  â€¢ Variant A: Counter-based        â†’ 12x faster  â† WINNER      â”‚
â”‚  â€¢ Variant B: Set intersection     â†’ 8x faster                 â”‚
â”‚  â€¢ Variant C: Sorting approach     â†’ 3x faster                 â”‚
â”‚  â€¢ Variant D: NumPy unique         â†’ 15x faster (needs numpy)  â”‚
â”‚  â€¢ Variant E: Dict comprehension   â†’ 10x faster                â”‚
â”‚                                                                 â”‚
â”‚  Saved: A, B, C, D, E (all stored in history)                  â”‚
â”‚                                                                 â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚
â”‚                                                                 â”‚
â”‚  ITERATION 2 (user runs again)                                  â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                  â”‚
â”‚  System knows: A, B, C, D, E already tried                     â”‚
â”‚                                                                 â”‚
â”‚  New variants (MUST be different):                              â”‚
â”‚  â€¢ Variant F: Cython typed         â†’ 25x faster â† NEW WINNER   â”‚
â”‚  â€¢ Variant G: Bloom filter approx  â†’ 50x faster (probabilistic)â”‚
â”‚  â€¢ Variant H: Parallel multiproc   â†’ 18x faster                â”‚
â”‚  â€¢ Variant I: C extension          â†’ 30x faster                â”‚
â”‚  â€¢ Variant J: PyPy optimized       â†’ 20x faster                â”‚
â”‚                                                                 â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚
â”‚                                                                 â”‚
â”‚  ITERATION 3 (user runs again)                                  â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                  â”‚
â”‚  System knows: A, B, C, D, E, F, G, H, I, J already tried      â”‚
â”‚                                                                 â”‚
â”‚  New variants (exploring edge cases):                           â”‚
â”‚  â€¢ Variant K: SIMD vectorized      â†’ 28x faster                â”‚
â”‚  â€¢ Variant L: Memory-mapped        â†’ 22x faster (large files)  â”‚
â”‚  â€¢ Variant M: Generator-based      â†’ 5x faster (low memory)    â”‚
â”‚  â€¢ Variant N: Rust binding         â†’ 35x faster â† NEW WINNER   â”‚
â”‚  â€¢ Variant O: Hybrid adaptive      â†’ 30x faster                â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### How Uniqueness Is Enforced

```python
# Variant Generator uses "negative prompting"

prompt = f"""
Generate a NEW implementation for: {function_signature}

ALREADY TRIED (DO NOT REPEAT THESE APPROACHES):
{list_of_previous_variants}

Requirements for new variant:
- Must be fundamentally DIFFERENT from all above
- Can use different: algorithm, data structure, library, paradigm
- Explore: parallel, vectorized, native extensions, approximations

Generate implementation #{ len(previous) + 1 }:
"""
```

### Continuous Mode

```
/codeforge optimize --continuous

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   CONTINUOUS OPTIMIZATION                        â”‚
â”‚                   Press Ctrl+C to stop                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  Target: services/geo.py:find_nearest_driver()                 â”‚
â”‚  Current best: Variant A (12x faster)                          â”‚
â”‚                                                                 â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚
â”‚                                                                 â”‚
â”‚  Iteration 1: 5 variants tested                                â”‚
â”‚  â””â”€ Best: Variant A (12x) âœ“                                    â”‚
â”‚                                                                 â”‚
â”‚  Iteration 2: 5 new variants tested                            â”‚
â”‚  â””â”€ Best: Variant F (25x) â¬†ï¸ NEW RECORD                         â”‚
â”‚                                                                 â”‚
â”‚  Iteration 3: 5 new variants tested                            â”‚
â”‚  â””â”€ Best: Variant N (35x) â¬†ï¸ NEW RECORD                         â”‚
â”‚                                                                 â”‚
â”‚  Iteration 4: 5 new variants tested                            â”‚
â”‚  â””â”€ No improvement (best remains 35x)                          â”‚
â”‚                                                                 â”‚
â”‚  Iteration 5: 5 new variants tested                            â”‚
â”‚  â””â”€ Variant Q (34x) - close but not better                     â”‚
â”‚                                                                 â”‚
â”‚  Iteration 6: 5 new variants tested                            â”‚
â”‚  â””â”€ No improvement                                              â”‚
â”‚                                                                 â”‚
â”‚  ^C â† User stops                                                â”‚
â”‚                                                                 â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚
â”‚                                                                 â”‚
â”‚  SUMMARY                                                        â”‚
â”‚  â€¢ Iterations: 6                                                â”‚
â”‚  â€¢ Variants tested: 30 (all unique)                            â”‚
â”‚  â€¢ Best found: Variant N (35x faster)                          â”‚
â”‚  â€¢ Applied: Yes                                                 â”‚
â”‚  â€¢ Tests: All passing                                           â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Until-Plateau Mode

```
/codeforge optimize --until-plateau --plateau-threshold=3

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   PLATEAU DETECTION                              â”‚
â”‚                                                                 â”‚
â”‚  Stops when: No improvement for 3 consecutive iterations       â”‚
â”‚                                                                 â”‚
â”‚  Iteration 1: Best = 12x                                       â”‚
â”‚  Iteration 2: Best = 25x  â¬†ï¸                                    â”‚
â”‚  Iteration 3: Best = 35x  â¬†ï¸                                    â”‚
â”‚  Iteration 4: Best = 35x  (no change) [1/3]                    â”‚
â”‚  Iteration 5: Best = 36x  â¬†ï¸ (reset counter)                    â”‚
â”‚  Iteration 6: Best = 36x  (no change) [1/3]                    â”‚
â”‚  Iteration 7: Best = 36x  (no change) [2/3]                    â”‚
â”‚  Iteration 8: Best = 36x  (no change) [3/3]                    â”‚
â”‚                                                                 â”‚
â”‚  PLATEAU REACHED - Stopping                                     â”‚
â”‚  Final best: 36x faster                                        â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Variant History Storage

```sql
-- All variants are stored for future reference
CREATE TABLE variant_history (
    id UUID PRIMARY KEY,
    function_signature TEXT,
    iteration INTEGER,
    variant_code TEXT,
    variant_approach TEXT,      -- "counter-based", "cython", etc.
    speedup FLOAT,
    memory_change FLOAT,
    is_valid BOOLEAN,
    is_winner BOOLEAN,
    created_at TIMESTAMP,
    
    -- For uniqueness checking
    code_hash TEXT,             -- Hash of normalized code
    approach_embedding VECTOR   -- Semantic embedding of approach
);

-- Ensure no duplicate approaches
CREATE UNIQUE INDEX idx_unique_approach 
ON variant_history(function_signature, code_hash);
```

### Configuration

```yaml
codeforge:
  optimizer:
    # Profiling settings
    profiling:
      enabled: true
      tools:
        time: "py-spy"           # or cProfile, scalene
        memory: "memory_profiler"
        trace: "viztracer"
      min_time_threshold: 100    # ms - ignore faster functions
      min_memory_threshold: 50   # MB - ignore smaller allocations
      min_call_count: 100        # ignore rarely called functions
    
    # Iteration settings
    iterations:
      default: 1
      max: 100                   # safety limit for --continuous
      variants_per_iteration: 5
      
    # Uniqueness enforcement
    uniqueness:
      check_code_hash: true      # exact code match
      check_approach: true       # semantic similarity
      similarity_threshold: 0.8  # reject if >80% similar
      
    # Plateau detection
    plateau:
      enabled: true
      threshold: 3               # iterations without improvement
      min_improvement: 0.05      # 5% to count as improvement
```

### Optimizer Flow

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   POST-DEVELOPMENT OPTIMIZER                     â”‚
â”‚                                                                 â”‚
â”‚  Scanning project: my-delivery-service/                         â”‚
â”‚  Files analyzed: 47                                             â”‚
â”‚  Functions found: 234                                           â”‚
â”‚                                                                 â”‚
â”‚  [â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ] 100% - Analysis complete                â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   OPTIMIZATION OPPORTUNITIES                     â”‚
â”‚                                                                 â”‚
â”‚  Found 18 functions that can be optimized                       â”‚
â”‚                                                                 â”‚
â”‚  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• â”‚
â”‚  ğŸ”´ CRITICAL (P0) - High impact, frequently called              â”‚
â”‚  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• â”‚
â”‚                                                                 â”‚
â”‚  1. services/geo.py:find_nearest_driver()                       â”‚
â”‚     â””â”€ Current: O(nÂ²) brute force distance calculation          â”‚
â”‚     â””â”€ Problem: Called 10K+ times/hour, 340ms avg               â”‚
â”‚     â””â”€ Solution: R-tree spatial index                           â”‚
â”‚     â””â”€ Expected improvement: ~500x faster                       â”‚
â”‚     [Optimize Now] [Show Variants] [Skip]                       â”‚
â”‚                                                                 â”‚
â”‚  2. services/orders.py:calculate_delivery_fee()                 â”‚
â”‚     â””â”€ Current: Repeated API calls for distance                 â”‚
â”‚     â””â”€ Problem: No caching, 200ms per call                      â”‚
â”‚     â””â”€ Solution: LRU cache + batch geocoding                    â”‚
â”‚     â””â”€ Expected improvement: ~50x faster (cache hits)           â”‚
â”‚     [Optimize Now] [Show Variants] [Skip]                       â”‚
â”‚                                                                 â”‚
â”‚  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• â”‚
â”‚  ğŸŸ¡ IMPORTANT (P1) - Medium impact                              â”‚
â”‚  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• â”‚
â”‚                                                                 â”‚
â”‚  3. utils/validation.py:validate_phone()                        â”‚
â”‚     â””â”€ Current: Regex compiled on every call                    â”‚
â”‚     â””â”€ Solution: Pre-compiled regex at module level             â”‚
â”‚     â””â”€ Expected improvement: ~10x faster                        â”‚
â”‚     [Optimize Now] [Skip]                                       â”‚
â”‚                                                                 â”‚
â”‚  4. api/routes.py:serialize_order()                             â”‚
â”‚     â””â”€ Current: Manual dict building                            â”‚
â”‚     â””â”€ Solution: Pydantic with __slots__                        â”‚
â”‚     â””â”€ Expected improvement: ~3x faster                         â”‚
â”‚     [Optimize Now] [Skip]                                       â”‚
â”‚                                                                 â”‚
â”‚  ... (5 more P1 items)                                          â”‚
â”‚                                                                 â”‚
â”‚  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• â”‚
â”‚  ğŸŸ¢ OPTIONAL (P2) - Low impact, nice to have                    â”‚
â”‚  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• â”‚
â”‚                                                                 â”‚
â”‚  9. helpers/formatters.py:format_currency()                     â”‚
â”‚     â””â”€ Current: String concatenation                            â”‚
â”‚     â””â”€ Solution: f-strings                                      â”‚
â”‚     â””â”€ Expected improvement: ~1.5x faster                       â”‚
â”‚     [Optimize Now] [Skip]                                       â”‚
â”‚                                                                 â”‚
â”‚  ... (9 more P2 items)                                          â”‚
â”‚                                                                 â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚
â”‚  Summary: 2 Critical â”‚ 7 Important â”‚ 9 Optional                 â”‚
â”‚                                                                 â”‚
â”‚  [Optimize All Critical] [Optimize All] [Export Report]         â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Priority Calculation

```python
Priority Score = (Impact Ã— Frequency Ã— Potential_Speedup) / Effort

Where:
- Impact = How critical is this function? (1-10)
- Frequency = Calls per hour from profiling/estimation
- Potential_Speedup = Expected improvement (2x, 10x, 100x)
- Effort = Complexity of optimization (1-10)

Example:
  find_nearest_driver():
  Impact=9, Frequency=10000, Speedup=500, Effort=3
  Score = (9 Ã— 10000 Ã— 500) / 3 = 15,000,000 â†’ P0 Critical
  
  format_currency():
  Impact=2, Frequency=1000, Speedup=1.5, Effort=1
  Score = (2 Ã— 1000 Ã— 1.5) / 1 = 3,000 â†’ P2 Optional
```

### Batch Optimization Mode

```
/codeforge optimize --auto --level=critical

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   BATCH OPTIMIZATION                             â”‚
â”‚                                                                 â”‚
â”‚  Mode: Automatic                                                â”‚
â”‚  Level: Critical (P0) only                                      â”‚
â”‚                                                                 â”‚
â”‚  Processing 2 critical functions...                             â”‚
â”‚                                                                 â”‚
â”‚  [1/2] find_nearest_driver()                                    â”‚
â”‚        â”œâ”€ Generating variants... âœ“                              â”‚
â”‚        â”œâ”€ Benchmarking... âœ“                                     â”‚
â”‚        â”œâ”€ Best: R-tree index (487x faster)                      â”‚
â”‚        â”œâ”€ Running tests... âœ“ (23/23 passed)                     â”‚
â”‚        â””â”€ Applied âœ“                                             â”‚
â”‚                                                                 â”‚
â”‚  [2/2] calculate_delivery_fee()                                 â”‚
â”‚        â”œâ”€ Generating variants... âœ“                              â”‚
â”‚        â”œâ”€ Benchmarking... âœ“                                     â”‚
â”‚        â”œâ”€ Best: LRU cache (52x faster)                          â”‚
â”‚        â”œâ”€ Running tests... âœ“ (18/18 passed)                     â”‚
â”‚        â””â”€ Applied âœ“                                             â”‚
â”‚                                                                 â”‚
â”‚  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•   â”‚
â”‚  OPTIMIZATION COMPLETE                                          â”‚
â”‚                                                                 â”‚
â”‚  Functions optimized: 2                                         â”‚
â”‚  Total speedup: ~270x average                                   â”‚
â”‚  Tests passed: 41/41                                            â”‚
â”‚  Patterns learned: 2 (saved to Knowledge Base)                  â”‚
â”‚                                                                 â”‚
â”‚  [View Changes] [Run Full Test Suite] [Commit]                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Complete Workflow

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    CODEFORGE COMPLETE FLOW                       â”‚
â”‚                                                                 â”‚
â”‚                                                                 â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                               â”‚
â”‚   â”‚ User writes â”‚                                               â”‚
â”‚   â”‚   request   â”‚                                               â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜                                               â”‚
â”‚          â”‚                                                      â”‚
â”‚          â–¼                                                      â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                   â”‚
â”‚   â”‚        CodeForge Intercepts             â”‚                   â”‚
â”‚   â”‚         Analyzes intent                 â”‚                   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                   â”‚
â”‚                      â”‚                                          â”‚
â”‚          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                              â”‚
â”‚          â”‚                       â”‚                              â”‚
â”‚          â–¼                       â–¼                              â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                       â”‚
â”‚   â”‚  Pattern    â”‚         â”‚ No Pattern  â”‚                       â”‚
â”‚   â”‚   Found     â”‚         â”‚   Found     â”‚                       â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜                       â”‚
â”‚          â”‚                       â”‚                              â”‚
â”‚          â–¼                       â–¼                              â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”‚
â”‚   â”‚   Inject    â”‚         â”‚  Ask User:          â”‚               â”‚
â”‚   â”‚  context    â”‚         â”‚  [Generate Variants]â”‚               â”‚
â”‚   â”‚             â”‚         â”‚  [Use Best Practice]â”‚               â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â”‚
â”‚          â”‚                           â”‚                          â”‚
â”‚          â”‚               â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”‚
â”‚          â”‚               â”‚                       â”‚              â”‚
â”‚          â”‚               â–¼                       â–¼              â”‚
â”‚          â”‚        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚
â”‚          â”‚        â”‚  Generate   â”‚         â”‚   Write     â”‚       â”‚
â”‚          â”‚        â”‚  & Benchmarkâ”‚         â”‚  Standard   â”‚       â”‚
â”‚          â”‚        â”‚  Variants   â”‚         â”‚   Code      â”‚       â”‚
â”‚          â”‚        â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜       â”‚
â”‚          â”‚               â”‚                       â”‚              â”‚
â”‚          â”‚               â–¼                       â”‚              â”‚
â”‚          â”‚        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                â”‚              â”‚
â”‚          â”‚        â”‚ Select Best â”‚                â”‚              â”‚
â”‚          â”‚        â”‚ Save Patternâ”‚                â”‚              â”‚
â”‚          â”‚        â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜                â”‚              â”‚
â”‚          â”‚               â”‚                       â”‚              â”‚
â”‚          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â”‚
â”‚                          â”‚                                      â”‚
â”‚                          â–¼                                      â”‚
â”‚                   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                               â”‚
â”‚                   â”‚ Claude Code â”‚                               â”‚
â”‚                   â”‚ writes code â”‚                               â”‚
â”‚                   â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜                               â”‚
â”‚                          â”‚                                      â”‚
â”‚                          â–¼                                      â”‚
â”‚                   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                               â”‚
â”‚                   â”‚  Optional:  â”‚                               â”‚
â”‚                   â”‚ Post-Dev    â”‚                               â”‚
â”‚                   â”‚ Optimizer   â”‚                               â”‚
â”‚                   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                               â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## MCP Tools (Updated)

### Proactive Tools (Always-on)

| Tool | Description |
|------|-------------|
| `codeforge_intercept` | Analyzes user intent, searches KB |
| `codeforge_inject` | Adds pattern context to prompt |
| `codeforge_plan_enhance` | Enhances plan with patterns |

### Variant Generation Tools

| Tool | Description |
|------|-------------|
| `codeforge_generate_variants` | Creates N implementation variants |
| `codeforge_benchmark_variants` | Benchmarks all variants |
| `codeforge_select_best` | Selects and saves winner |

### Post-Development Tools

| Tool | Description |
|------|-------------|
| `codeforge_scan` | Scans project for optimization opportunities |
| `codeforge_prioritize` | Ranks functions by optimization priority |
| `codeforge_optimize_function` | Optimizes single function |
| `codeforge_optimize_batch` | Batch optimization by priority level |
| `codeforge_report` | Generates optimization report |

---

## Configuration (Updated)

```yaml
codeforge:
  mode: always
  
  # Proactive settings
  proactive:
    enabled: true
    auto_inject: true          # Inject patterns automatically
    
  # When no pattern found
  no_pattern_behavior:
    action: ask                 # ask | auto_generate | skip
    default_choice: generate    # If ask, pre-select this option
    variants_count: 15          # How many variants to generate
    benchmark_timeout: 60       # Seconds per variant
    
  # Post-development optimizer
  optimizer:
    scan_on_commit: false       # Auto-scan before git commit
    scan_schedule: null         # Cron expression for scheduled scans
    auto_apply:
      critical: false           # Auto-apply P0 optimizations
      important: false          # Auto-apply P1 optimizations
      optional: false           # Auto-apply P2 optimizations
    require_tests: true         # Only apply if tests pass
    
  # Priority thresholds
  priorities:
    critical:                   # P0
      min_frequency: 1000       # Calls per hour
      min_speedup: 10           # Expected improvement
    important:                  # P1
      min_frequency: 100
      min_speedup: 3
    optional:                   # P2
      min_frequency: 0
      min_speedup: 1.2
```

---

## Example: Full Session

```
# 1. User starts new feature
User: "Add real-time order tracking with location updates"

# 2. CodeForge intercepts, finds pattern for "real-time location"
[CODEFORGE] Found pattern: websocket_geo_streaming (5 optimizations)
[CODEFORGE] Injecting context...

# 3. But no pattern for "efficient location diff calculation"
[CODEFORGE] âš ï¸ No pattern for: "calculate_location_change_significance"

  Options:
  [1] Generate & Benchmark Variants (recommended)
  [2] Use standard implementation, optimize later

User: 1

# 4. CodeForge generates variants
[CODEFORGE] Generating 12 variants...
[CODEFORGE] Benchmarking...
[CODEFORGE] ğŸ† Winner: Haversine with early-exit (8.3x faster)
[CODEFORGE] Pattern saved: haversine_optimized_v1

# 5. Claude writes code with both patterns
Claude: "Implementing real-time tracking with:
- WebSocket streaming (from CodeForge pattern)
- Optimized Haversine for location diff (just benchmarked)"

# 6. Later, user runs post-dev optimizer
User: /codeforge optimize

[CODEFORGE] Scanning...
[CODEFORGE] Found 5 optimization opportunities:
  ğŸ”´ P0: 1 function (location serialization)
  ğŸŸ¡ P1: 2 functions
  ğŸŸ¢ P2: 2 functions

User: "Optimize critical"

[CODEFORGE] Optimizing location_to_dict()...
[CODEFORGE] âœ“ Applied: msgpack serialization (23x faster)
```
